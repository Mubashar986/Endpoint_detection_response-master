Response Actions Feature Analysis: Kill Process / Isolate Host
SECTION 1: Feature Researcher & System Analyst
1. Feature Definition & Context
What It Is: Response Actions are remote commands sent from the EDR server to the endpoint agent to contain, remediate, or investigate a threat. The two most critical actions are:

Kill Process: Immediately terminate a running process by PID (Process ID) or name.
Isolate Host: Block all network traffic except communication with the EDR server.
Why It Exists: When a threat is detected (e.g., ransomware encrypting files), time is critical. Manual intervention (RDP into the host, open Task Manager) can take 5-10 minutes. Automated response actions reduce Mean Time to Respond (MTTR) from minutes to seconds.

Industry Context:

CrowdStrike Falcon: "Contain Host", "Kill Process", "Delete File"
SentinelOne: "Disconnect from Network", "Terminate Process", "Quarantine"
Carbon Black: "Isolate Endpoint", "Ban Process Hash", "Live Response API"
2. Real-world Use Cases
Use Case	Action	Outcome
Ransomware Detection	Kill wannacry.exe (PID 3456)	Stops encryption before 10% of files are damaged
C2 Beaconing	Isolate host	Prevents data exfiltration while SOC investigates
Brute Force Attack	Isolate attacker's endpoint	Stops lateral movement to domain controller
Cryptominer	Kill xmrig.exe + all children	Restores CPU to normal, prevents electricity waste
3. How This Feature Works Internally
A. Kill Process
Windows Implementation:

HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
if (hProcess != NULL) {
    TerminateProcess(hProcess, 1); // Exit code 1
    CloseHandle(hProcess);
}
Key Windows APIs:

OpenProcess(PROCESS_TERMINATE, ...): Get handle with termination rights
TerminateProcess(handle, exitCode): Unconditional termination
Privilege Requirements:

Administrator (or SYSTEM) if the target process is owned by another user
SeDebugPrivilege may be needed for protected processes
Process Tree Handling:

TerminateProcess does NOT kill child processes automatically
Advanced EDRs offer "Kill Process Tree" using recursive enumeration (CreateToolhelp32Snapshot)
B. Isolate Host
Modern Approach: Windows Filtering Platform (WFP) WFP is a kernel-level firewall API (Vista+). EDRs use it to:

Create a BLOCK ALL filter for inbound/outbound traffic
Add ALLOW exceptions for:
EDR agent â†’ EDR server (specific IP/port)
DNS (port 53)
DHCP (port 67/68)
Legacy Approach: Disable Network Adapters (WMI)

Get-WmiObject Win32_NetworkAdapter | Where-Object {$_.NetEnabled -eq $true} | Invoke-WmiMethod -Name Disable
Downside: Breaks EDR communication unless agent uses cellular/satellite link
Microsoft Defender for Endpoint Approach:

API: POST /api/machines/{id}/isolate
Options: "Full" or "Selective" isolation
Maintains Windows Update + EDR connectivity
4. Key Components & Processes
Component	Responsibility
Server/Backend	Validates command, logs action, tracks status
WebSocket/HTTP	Delivers command: {"type": "kill_process", "pid": 3456}
Agent (CommandProcessor)	Parses command, calls Windows API, returns result
Privilege Manager	Ensures agent runs as SYSTEM or elevates privileges
Audit Log	Records WHO issued command, WHEN, and OUTCOME
Data Flow:

SOC Analyst clicks "Kill Process 3456" in web UI
Backend validates (auth token, role permissions)
Backend sends WebSocket message: {"type": "kill_process", "pid": 3456}
Agent receives, validates, executes TerminateProcess
Agent replies: {"status": "success", "pid": 3456, "exit_code": 1}
Backend updates Alert to "Remediated"
5. Constraints & Assumptions
Constraint	Impact
Agent must run as SYSTEM	Cannot kill processes owned by TrustedInstaller otherwise
Protected Processes	Cannot kill AntiMalware Light (PPL) processes without kernel driver
Network Isolation breaks RDP	SOC cannot RDP into isolated host (must use agent's reverse shell)
False Positives	Killing wrong process can crash critical apps (e.g., SQL Server)
WFP Requires Vista+	Windows XP/2003 need legacy netsh firewall
Assumptions:

Agent is already running with admin privileges
WebSocket connection is authenticated (via auth_token)
Server has a mechanism to "undo" isolation (deisolate command)
6. Risks & Tradeoffs
Risks:
System Instability: TerminateProcess is abrupt. No cleanup, no saving state. If you kill explorer.exe, the user loses their taskbar.
Over-Isolation: If isolation filter is too aggressive (blocks DHCP), the endpoint loses IP and becomes unreachable.
Privilege Escalation Vector: If attacker compromises the agent, they can kill EDR processes or isolate the host from updates.
Audit Gaps: If kill/isolate isn't logged properly, compliance audits fail (GDPR, SOC2).
Tradeoffs:
Approach	Pro	Con
Kill Process only (no tree)	Simple, fast	Leaves child processes running
Kill Process Tree	Thorough cleanup	Risk of killing unrelated processes with same parent
WFP Isolation	Granular control	Complex implementation, requires kernel knowledge
Adapter Disable	Dead simple	Breaks EDR comms
7. Smarter, Cheaper Alternatives
Alternative	When to Use	Cost
Suspend Process (NtSuspendProcess)	Forensics (want memory dump first)	Low risk, reversible
Request Graceful Exit (WM_CLOSE)	Non-malicious processes (e.g., misbehaving app)	Safer than TerminateProcess
Firewall Rule (netsh)	Simple isolation without WFP	Easier for MVP, less granular
Group Policy Isolation	Enterprise environments with AD	Requires domain, slower (GPO refresh)
Recommendation for MVP:

Kill Process: Use TerminateProcess (no tree recursion initially)
Isolate: Use netsh advfirewall commands (simpler than WFP API)
SECTION 2: MVP Scope Enforcer
8. Problem Summary
Current State:

Agent has only reverse_shell for response
No ability to stop malicious processes without manual intervention
No network containment capabilities
User Pain Point:

Analyst detects ransomware â†’ Must manually RDP â†’ Open Task Manager â†’ Kill process â†’ 5+ minutes wasted â†’ Files already encrypted
MVP Goal:

Add 2 commands: kill_process (by PID) and isolate_host (block all except EDR traffic)
Reduce MTTR from 5 minutes to 10 seconds
9. What the MVP Actually Needs
Minimum Viable Features:
Kill Process (by PID)

Input: {"type": "kill_process", "pid": 1234}
Output: {"status": "success/failed", "message": "..."}
Implementation: 15 lines of C++ using TerminateProcess
Isolate Host

Input: {"type": "isolate_host"}
Output: {"status": "isolated"}
Implementation: Call netsh advfirewall firewall add rule name="EDR_BLOCK_ALL" dir=out action=block
Exception: Add allow rule for EDR server IP
Deisolate Host

Input: {"type": "deisolate_host"}
Output: {"status": "deisolated"}
Implementation: netsh advfirewall firewall delete rule name="EDR_BLOCK_ALL"
Backend UI Buttons

"Kill Process" button on Alert detail page
"Isolate Endpoint" button on Host detail page
10. What NOT to Build Right Now
âŒ Kill Process Tree (recursive child enumeration)
âŒ WFP API Implementation (kernel-level firewall)
âŒ Suspend/Resume Process (forensics feature)
âŒ Ban Process Hash (prevention, not response)
âŒ Memory Dump Before Kill (nice-to-have, not critical)
âŒ Selective Isolation (allow certain apps)
âŒ Automated Response (auto-kill on detection)
âŒ Role-Based Access Control (who can kill what)
âŒ Kill Confirmation Dialog (just log it)
âŒ Undo Kill (impossible, process is dead)

11. Key Research Insights (Condensed)
âœ… TerminateProcess is the standard API (used by Task Manager)
âœ… netsh advfirewall is simpler than WFP for MVP
âœ… Must allow EDR server IP in isolation rules
âœ… Require admin privileges (agent should run as SYSTEM)
âŒ Killing protected processes (PPL) requires kernel driver (out of scope)
âŒ WFP is overkill for MVP, use netsh
12. Required Modules / Endpoints / Data
Agent (C++)
New Functions in 
CommandProcessor.cpp
:

bool killProcess(DWORD pid);
bool isolateHost(const std::string& edrServerIp);
bool deisolateHost();
New Command Types:

"kill_process" â†’ killProcess(pid)
"isolate_host" â†’ isolateHost(serverIp)
"deisolate_host" â†’ deisolateHost()
Backend (Django)
New API Endpoint:

POST /api/v1/response/kill_process/
{
  "endpoint_id": "EP-12345",
  "pid": 3456
}
POST /api/v1/response/isolate_host/
{
  "endpoint_id": "EP-12345"
}
Database (Optional for MVP):

ResponseAction model (log who, when, what)
action_type (kill_process/isolate_host)
endpoint_id
user_id (who issued it)
timestamp
status (success/failed)
13. Simplest Preliminary Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         WebSocket         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Backend   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚  Agent (C++) â”‚
â”‚  (Django)   â”‚  {"type": "kill_process"  â”‚              â”‚
â”‚             â”‚   "pid": 3456}            â”‚OpenProcess() â”‚
â”‚             â”‚                           â”‚Terminate()   â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚              â”‚
â”‚             â”‚  {"status": "success"}    â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ Logs action to DB
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SQLite/Mongoâ”‚
â”‚ ResponseLog â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
No New Infrastructure Needed:

Uses existing WebSocket connection
Uses existing auth token
No new microservices
14. Testing Checklist
Agent Testing:
 Open notepad.exe, get PID, send kill_process â†’ Notepad closes
 Try to kill non-existent PID â†’ Returns error
 Try to kill SYSTEM process (e.g., csrss.exe) â†’ Returns "Access Denied" error
 Send isolate_host â†’ Verify cannot ping 8.8.8.8, but can still reach EDR server
 Send deisolate_host â†’ Verify can ping 8.8.8.8 again
Backend Testing:
 POST to /api/response/kill_process/ with valid token â†’ 200 OK
 POST with invalid token â†’ 401 Unauthorized
 Check database: ResponseAction record exists
 UI: Click "Kill Process" button â†’ Modal shows "Success"
Integration Testing:
 Trigger ransomware simulation â†’ Alert fires â†’ Click "Kill Process" â†’ Ransomware stops
15. Future Enhancements (Park These)
Kill Process Tree (recursive child kill)
WFP API (replace netsh with kernel-level filtering)
Automated Response (auto-kill on certain rules)
RBAC (only Tier 2 analysts can kill processes)
Approval Workflow (Manager must approve isolation)
Memory Dump (capture process memory before kill)
Ban Hash (prevent process from running again)
Selective Isolation (allow RDP, block everything else)
16. Red Flags (User Overbuilding Patterns)
ğŸš© "We should support SIGMA rule-based automated response"
â†’ NO. That's Phase 2. For now, manual response only.

ğŸš© "Let's implement WFP properly with driver signing"
â†’ NO. Use netsh first. WFP is overkill for MVP.

ğŸš© "We need approval workflows and audit trails"
â†’ Partial NO. Log the action (1 table), but skip approval UI.

ğŸš© "Kill Process Tree with full parent-child enumeration"
â†’ NO. Kill single PID first. Tree is Phase 2.

ğŸš© "Support Linux/macOS isolation too"
â†’ NO. Windows only. Linux agent doesn't even exist yet.

17. Final Recommendation (Strict, Short)
Build This (MVP):

3 new commands in 
CommandProcessor.cpp
:

kill_process (PID only)
isolate_host (netsh block all + allow EDR IP)
deisolate_host (netsh delete rules)
2 backend endpoints:

POST /api/v1/response/kill_process/
POST /api/v1/response/isolate_host/
2 UI buttons:

"Kill Process" (on Alert page)
"Isolate Host" (on Endpoint page)
1 database table:

ResponseAction (log who, when, what)
Estimate:

Agent changes: 2 hours (50 lines of C++)
Backend changes: 3 hours (API + logging)
UI changes: 2 hours (buttons + modals)
Testing: 2 hours
Total: 9 hours (1 dev day)
Success Criteria:

SOC analyst can kill a process in < 10 seconds
SOC analyst can isolate a host in < 10 seconds
All actions are logged to database
No crashes, no false positives in testing
Next Step:
